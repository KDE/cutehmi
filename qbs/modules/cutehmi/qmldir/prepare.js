var FileInfo = require("qbs.FileInfo");

function writeComment(f)
{
	f.writeLine("# This file has been autogenerated by 'cutehmi.qmldir' Qbs module.")
}

function writeModule(f, moduleIdentifier)
{
	f.writeLine("module " + moduleIdentifier)
}

// Qbs does not allow for copying of cyclic structures like inputs or overridingInputs, which prevents us from merging inputs
// and overridingInputs into single array or perform non-destructive operations on these arrays without touching original references,
// so this ugly helper function is provided to share code in writeInputs() function.
function writeInput(f, puppetPrefix, config, input, overridingInputs)
{
	var usedOverride = undefined

	// Calculate relative path between given input and 'qmldir' file (output) location.
	// FileInfo.relativePath() assumes first argument to be a directory, thus get directory of 'qmldir' with FileInfo.path().
	var relativePath = FileInfo.relativePath(FileInfo.path(config.output.filePath), input.filePath)
	// Add prefix and clean path from redundant '..' and '.'.
	relativePath = FileInfo.cleanPath(puppetPrefix + "/" + relativePath)

	// If there are overriding inputs check if current input is overriden and reassign input variable if necessary. Modify
	// relativePath accordingly.
	if (overridingInputs !== undefined)
		for (var ii = 0; ii < overridingInputs.length; ii++) {
			if (overridingInputs[ii].baseName === input.baseName) {
				input = overridingInputs[ii]
				// Calculate relative path between given input and 'qmldir' file (output) location.
				// FileInfo.relativePath() assumes first argument to be a directory, thus get directory of 'qmldir' with FileInfo.path().
				relativePath = FileInfo.relativePath(FileInfo.path(config.output.filePath), overridingInputs[ii].filePath)
				usedOverride = ii
				break
			}
		}

	var j
	var excludePath = FileInfo.relativePath(config.inputsSourceBase, input.filePath)
	for (j = 0; j < config.excludedInputs.length; j++)
		if (excludePath.match(config.excludedInputs[j]))
			break
	if (j !== config.excludedInputs.length)	// This means pattern has been found.
		return usedOverride

	if (input.fileTags.contains("qml"))
		writeQmlType(f, input, relativePath, config.major, config.minor, config.filesMap, config.singletons)
	else if (input.fileTags.contains("js"))
		writeJsResource(f, input, relativePath, config.major, config.minor, config.filesMap)

	return usedOverride
}

function writeInputs(f, config)
{
	// Take into account source base difference, between inputs and 'qmldir', which happens, when 'qmldir' belongs to a puppet.
	var puppetPrefix = FileInfo.relativePath(config.inputsSourceBase, config.outputSourceBase)

	// Take into account difference between installation directory of 'qmldir' file and inputs, which happens for puppets.
	puppetPrefix = FileInfo.relativePath(config.outputInstallDir, config.inputsInstallDir) + "/" + puppetPrefix

	var usedOverrides = []
	for (var i = 0; i < config.inputs.length; i++) {
		var usedOverride = writeInput(f, puppetPrefix, config, config.inputs[i], config.overridingInputs)
		if (usedOverride !== undefined)
			usedOverrides.push(usedOverride)
	}

	// Additional components provided by a puppet.
	if (config.overridingInputs !== undefined) {
		for (i = 0; i < config.overridingInputs.length; i++) {
			if (!usedOverrides.contains(i))
				writeInput(f, ".", config, config.overridingInputs[i], undefined)
		}
	}
}

function writeQmlType(f, qmlInput, relativePath, major, minor, filesMap, singletons)
{
	var maybeSingleton = ""
	if (singletons.contains(qmlInput.baseName))
		maybeSingleton = "singleton "

	if (filesMap[relativePath] !== undefined)
		f.writeLine(filesMap[qmlInput.fileName] + " " + relativePath)
	else
		f.writeLine(maybeSingleton + qmlInput.baseName + " " + major + "." + minor + " " + relativePath)
}

function writeJsResource(f, jsInput, relativePath, major, minor, filesMap)
{
	if (filesMap[relativePath] !== undefined)
		f.writeLine(filesMap[jsInput.fileName] + " " + relativePath)
	else
		f.writeLine(jsInput.baseName + " " + major + "." + minor + " " + relativePath)
}

function writePlugins(f, plugins, className)
{
	for (var i = 0; i < plugins.length; i++)
		f.writeLine("plugin " + plugins[i].name + " " + plugins[i].path)
	f.writeLine("classname " + className)
}

function writeTypeInfo(f, typeInfo)
{
	f.writeLine("typeinfo " +  typeInfo)
}

function writeDesignerSupported(f)
{
	f.writeLine("designersupported")
}

function writeAdditionalEntries(f, additionalEntries)
{
	for (var i = 0; i < additionalEntries.length; i++)
		f.writeLine(additionalEntries[i])
}

function writeEntries(f, config)
{
	writeComment(f)

	f.writeLine("");
	writeModule(f, config.moduleIdentifier)

	if (config.inputs !== undefined) {
		f.writeLine("");
		writeInputs(f, config)
	}

	if (config.hasPlugin) {
		f.writeLine("");
		writePlugins(f, config.plugins, config.className)
	}

	if (config.typeInfo !== undefined) {
		f.writeLine("")
		writeTypeInfo(f, config.typeInfo)
	}

	if (config.designerSupported) {
		f.writeLine("")
		writeDesignerSupported(f)
	}

	if (config.additionalEntries.length > 0) {
		f.writeLine("")
		writeAdditionalEntries(f, config.additionalEntries)
	}
}

function writeGitignore(f)
{
	var qmldirLinePresent = false
	var empty = false
	if (f.atEof())
		empty = true

	while (!f.atEof())
		if (f.readLine() === "qmldir")
			qmldirLinePresent = true

	if (!qmldirLinePresent) {
		if (!empty)
			f.writeLine("")
		f.writeLine("# Ignore 'qmldir' files (entry added by 'cutehmi.qmldir' Qbs module).")
		f.writeLine("qmldir");
	}
}

//(c)C: Copyright © 2019, Michał Policht <michal@policht.pl>. All rights reserved.
//(c)C: This file is a part of CuteHMI.
//(c)C: CuteHMI is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
//(c)C: CuteHMI is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
//(c)C: You should have received a copy of the GNU Lesser General Public License along with CuteHMI.  If not, see <https://www.gnu.org/licenses/>.
