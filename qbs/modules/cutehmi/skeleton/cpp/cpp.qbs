import qbs
import qbs.File
import qbs.FileInfo
import qbs.TextFile

/**
  Skeletal files generator for C++ extensions. Files, which are not generated by default and need generateXYZ property to be
  explicitly set to @p true, are not treated as artifacts.
  */
Module {
	additionalProductTypes: ["cutehmi.skeleton.cpp"]

	property bool generateCommon: true

	property bool generateException: false

	property bool generateInit: false

	property bool generateLogging: true

	property bool generateLoggingTest: false

	// TODO: remove obsolete metadata.hpp header
	property bool generateMetadata: true

	property bool generatePlatform: true

	property bool generateQMLPlugin: false

	property bool generateTestsQbs: generateLoggingTest

	readonly property bool generateNonArtifact: generateException || generateInit || generateLoggingTest || generateTestsQbs || generateQMLPlugin

	readonly property string includeDir: product.sourceDirectory + "/" + product.cutehmi.conventions.functions.includesSubdir(product.name)

	readonly property string sourceDir: product.sourceDirectory + "/" + product.cutehmi.conventions.functions.sourcesSubdir(product.name)

	readonly property string internalIncludeDir: product.sourceDirectory + "/" + product.cutehmi.conventions.functions.internalIncludesSubdir(product.name)

	readonly property string internalSourceDir: product.sourceDirectory + "/" + product.cutehmi.conventions.functions.internalSourcesSubdir(product.name)

	readonly property string autogenIncludeDir: product.sourceDirectory + "/" + product.cutehmi.conventions.functions.autogenIncludesSubdir(product.name)

	readonly property string autogenSourceDir: product.sourceDirectory + "/" + product.cutehmi.conventions.functions.autogenSourcesSubdir(product.name)

	readonly property string testsDir: product.sourceDirectory + "/" + product.cutehmi.conventions.functions.testsSubdir(product.name)

	readonly property string commonHeader: autogenIncludeDir + "/common.hpp"

	readonly property string exceptionHeader: includeDir + "/Exception.hpp"

	readonly property string initHeader: includeDir + "/Init.hpp"

	readonly property string initSource: sourceDir + "/Init.cpp"

	readonly property string loggingHeader: autogenIncludeDir + "/logging.hpp"

	readonly property string loggingSource: autogenSourceDir + "/logging.cpp"

	readonly property string metadataHeader: autogenIncludeDir + "/metadata.hpp"

	readonly property string platformHeader: autogenIncludeDir + "/platform.hpp"

	readonly property string qmlPluginHeader: internalSourceDir + "/QMLPlugin.hpp"

	readonly property string qmlPluginSource: internalSourceDir + "/QMLPlugin.cpp"

	readonly property string testLoggingSource: testsDir + "/test_logging.cpp"

	readonly property string testQbs: testsDir + "/Test.qbs"

	readonly property string testsQbs: testsDir + "/tests.qbs"

	readonly property string commonIncludeGuard: product.cutehmi.conventions.functions.includeGuard(project.sourceDirectory, product.cutehmi.skeleton.cpp.commonHeader)

	readonly property string exceptionIncludeGuard: product.cutehmi.conventions.functions.includeGuard(project.sourceDirectory, product.cutehmi.skeleton.cpp.exceptionHeader)

	readonly property string initIncludeGuard: product.cutehmi.conventions.functions.includeGuard(project.sourceDirectory, product.cutehmi.skeleton.cpp.initHeader)

	readonly property string loggingIncludeGuard: product.cutehmi.conventions.functions.includeGuard(project.sourceDirectory, product.cutehmi.skeleton.cpp.loggingHeader)

	readonly property string metadataIncludeGuard: product.cutehmi.conventions.functions.includeGuard(project.sourceDirectory, product.cutehmi.skeleton.cpp.metadataHeader)

	readonly property string platformIncludeGuard: product.cutehmi.conventions.functions.includeGuard(project.sourceDirectory, product.cutehmi.skeleton.cpp.platformHeader)

	readonly property string qmlPluginIncludeGuard: product.cutehmi.conventions.functions.includeGuard(project.sourceDirectory, product.cutehmi.skeleton.cpp.qmlPluginHeader)

	readonly property string macroPrefix: product.cutehmi.conventions.functions.macroPrefix(product.name)

	readonly property stringList namespaceArray: product.cutehmi.conventions.functions.namespaceArray(product.name)

	readonly property string namespace: product.cutehmi.conventions.functions.namespace(product.name)

	readonly property string loggingCategory: product.cutehmi.conventions.functions.loggingCategory(product.name)

	readonly property string dedicatedSubdir: product.cutehmi.conventions.functions.dedicatedSubdir(product.name)

	readonly property string initiallyGeneratedNotice: "This file has been initially autogenerated by 'cutehmi.skeleton.cpp' Qbs module."

	readonly property string autogeneratedNotice: "This file has been autogenerated by 'cutehmi.skeleton.cpp' Qbs module. Do not modify!"

	validate: {
		if (!File.exists(product.sourceDirectory + "/README.md"))
			console.warn("File 'README.md' does not exist in '" + product.sourceDirectory + "' directory, please create it (file should contain a description of an extension)")

		if (product.baseName === "CuteHMI")
			throw "Qbs module 'cutehmi.cpp.skeleton' should not be used by CuteHMI product"
	}

	Depends { name: "cutehmi.conventions" }

	Rule {
		condition: product.cutehmi.skeleton.cpp.generateCommon
		multiplex: true

		prepare: {
			var commonHppCmd = new JavaScriptCommand();
			commonHppCmd.description = "generating " + product.cutehmi.skeleton.cpp.commonHeader
			commonHppCmd.highlight = "codegen";
			commonHppCmd.includeGuard = product.cutehmi.skeleton.cpp.commonIncludeGuard
			commonHppCmd.autogeneratedNotice = product.cutehmi.skeleton.cpp.autogeneratedNotice
			commonHppCmd.usePlatform = product.cutehmi.skeleton.cpp.generatePlatform
			commonHppCmd.useMetadata = product.cutehmi.skeleton.cpp.generateMetadata
			commonHppCmd.useLogging = product.cutehmi.skeleton.cpp.generateLogging
			commonHppCmd.useCutehmi = product.cutehmi.skeleton.cpp.useCutehmi
			commonHppCmd.sourceCode = function() {
				File.makePath(FileInfo.path(product.cutehmi.skeleton.cpp.commonHeader))
				var f = new TextFile(product.cutehmi.skeleton.cpp.commonHeader, TextFile.WriteOnly)
				try {
					f.writeLine("#ifndef " + includeGuard)
					f.writeLine("#define " + includeGuard)

					f.writeLine("")
					f.writeLine("// " + autogeneratedNotice)

					f.writeLine("")
					if (usePlatform)
						f.writeLine("#include \"platform.hpp\" // IWYU pragma: export")
					if (useMetadata)
						f.writeLine("#include \"metadata.hpp\" // IWYU pragma: export")
					if (useLogging)
						f.writeLine("#include \"logging.hpp\"")

					f.writeLine("")
					f.writeLine("#include <cutehmi/MPtr.hpp>")
					f.writeLine("#include <cutehmi/macros.hpp>")

					f.writeLine("")
					f.writeLine("#include <QtGlobal>")

					f.writeLine("")
					f.writeLine("#endif")
				} finally {
					f.close()
				}
			}
			return [commonHppCmd]
		}

		Artifact {
			filePath: product.cutehmi.skeleton.cpp.commonHeader
			fileTags: ["hpp", "common.hpp", "cutehmi.skeleton.cpp"]
		}
	}

	Rule {
		condition: product.cutehmi.skeleton.cpp.generateLogging
		multiplex: true

		prepare: {
			var loggingHppCmd = new JavaScriptCommand();
			loggingHppCmd.description = "generating " + product.cutehmi.skeleton.cpp.loggingHeader
			loggingHppCmd.highlight = "codegen";
			loggingHppCmd.includeGuard = product.cutehmi.skeleton.cpp.loggingIncludeGuard
			loggingHppCmd.autogeneratedNotice = product.cutehmi.skeleton.cpp.autogeneratedNotice
			loggingHppCmd.macroPrefix = product.cutehmi.skeleton.cpp.macroPrefix
			loggingHppCmd.namespaceArray = product.cutehmi.skeleton.cpp.namespaceArray
			loggingHppCmd.loggingCategory = product.cutehmi.skeleton.cpp.loggingCategory
			loggingHppCmd.sourceCode = function() {
				File.makePath(FileInfo.path(product.cutehmi.skeleton.cpp.loggingHeader))
				var f = new TextFile(product.cutehmi.skeleton.cpp.loggingHeader, TextFile.WriteOnly)
				try {
					f.writeLine("#ifndef " + includeGuard)
					f.writeLine("#define " + includeGuard)

					f.writeLine("")
					f.writeLine("// " + autogeneratedNotice)

					f.writeLine("")
					f.writeLine("#include \"platform.hpp\"")
					f.writeLine("#include <cutehmi/loggingMacros.hpp>")

					f.writeLine("")
					f.writeLine(macroPrefix + "_API Q_DECLARE_LOGGING_CATEGORY(" + loggingCategory + ")")

					f.writeLine("")
					for (var level in namespaceArray)
						f.writeLine("namespace " + namespaceArray[level] + " {")

					f.writeLine("")
					f.writeLine("inline")
					f.writeLine("const QLoggingCategory & loggingCategory()")
					f.writeLine("{")
					f.writeLine("	CUTEHMI_LOGGING_CATEGORY_CHECK(" + loggingCategory + "());")
					f.writeLine("	return " + loggingCategory + "();")
					f.writeLine("}")

					f.writeLine("")
					for (var level in namespaceArray)
						f.writeLine("}")

					f.writeLine("")
					f.writeLine("#endif")
				} finally {
					f.close()
				}
			}

			var loggingCppCmd = new JavaScriptCommand();
			loggingCppCmd.description = "generating " + product.cutehmi.skeleton.cpp.loggingSource
			loggingCppCmd.highlight = "codegen";
			loggingCppCmd.autogeneratedNotice = product.cutehmi.skeleton.cpp.autogeneratedNotice
			loggingCppCmd.loggingCategory = product.cutehmi.skeleton.cpp.loggingCategory
			loggingCppCmd.loggingCategoryId = product.name
			loggingCppCmd.macroPrefix =product.cutehmi.skeleton.cpp.macroPrefix
			loggingCppCmd.useMetadata = product.cutehmi.skeleton.cpp.generateMetadata
			loggingCppCmd.sourceCode = function() {
				File.makePath(FileInfo.path(product.cutehmi.skeleton.cpp.loggingSource))
				var f = new TextFile(product.cutehmi.skeleton.cpp.loggingSource, TextFile.WriteOnly)
				try {
					f.writeLine("#include \"autogen/logging.hpp\"")
					if (useMetadata)
						f.writeLine("#include \"autogen/cutehmi.metadata.hpp\"")

					f.writeLine("")
					f.writeLine("// " + autogeneratedNotice)

					f.writeLine("")
					if (useMetadata)
						f.writeLine("Q_LOGGING_CATEGORY(" + loggingCategory + ", " + macroPrefix + "_NAME)")
					else
						f.writeLine("Q_LOGGING_CATEGORY(" + loggingCategory + ", \"" + loggingCategoryId + "\")")
				} finally {
					f.close()
				}
			}

			return [loggingHppCmd, loggingCppCmd]
		}

		Artifact {
			filePath: product.cutehmi.skeleton.cpp.loggingHeader
			fileTags: ["hpp", "logging.hpp", "cutehmi.skeleton.cpp"]
		}

		Artifact {
			filePath: product.cutehmi.skeleton.cpp.loggingSource
			fileTags: ["cpp", "logging.cpp", "cutehmi.skeleton.cpp"]
		}
	}

	Rule {
		condition: product.cutehmi.skeleton.cpp.generateMetadata
		inputs: ["cutehmi.metadata.hpp"]
		requiresInputs: true

		prepare: {
			if (!input)
				throw "No `cutehmi.metadata.hpp` found in product '" + product.name + "'. Either specify 'cutehmi.metadata' as its dependency or set 'cutehmi.skeleton.cpp.generateMetadata: false'."

			var metadataHppCmd = new JavaScriptCommand();
			metadataHppCmd.description = "generating " + product.cutehmi.skeleton.cpp.metadataHeader
			metadataHppCmd.highlight = "codegen";
			metadataHppCmd.includeGuard = product.cutehmi.skeleton.cpp.metadataIncludeGuard
			metadataHppCmd.autogeneratedNotice = product.cutehmi.skeleton.cpp.autogeneratedNotice
			metadataHppCmd.metadataHppPathPrefix = FileInfo.relativePath(FileInfo.path(product.cutehmi.skeleton.cpp.metadataHeader), input.filePath)
			metadataHppCmd.sourceCode = function() {
				File.makePath(FileInfo.path(product.cutehmi.skeleton.cpp.metadataHeader))
				var f = new TextFile(product.cutehmi.skeleton.cpp.metadataHeader, TextFile.WriteOnly)
				try {
					f.writeLine("#ifndef " + includeGuard)
					f.writeLine("#define " + includeGuard)

					f.writeLine("")
					f.writeLine("// " + autogeneratedNotice)

					f.writeLine("")
					f.writeLine("#include \"" + metadataHppPathPrefix + "\"")

					f.writeLine("")
					f.writeLine("#endif")
				} finally {
					f.close()
				}
			}

			return [metadataHppCmd]
		}

		Artifact {
			filePath: product.cutehmi.skeleton.cpp.metadataHeader
			fileTags: ["hpp", "metadata.hpp", "cutehmi.skeleton.cpp"]
		}
	}

	Rule {
		condition: product.cutehmi.skeleton.cpp.generatePlatform
		multiplex: true

		prepare: {
			var platformHppCmd = new JavaScriptCommand();
			platformHppCmd.description = "generating " + product.cutehmi.skeleton.cpp.platformHeader
			platformHppCmd.highlight = "codegen";
			platformHppCmd.includeGuard = product.cutehmi.skeleton.cpp.platformIncludeGuard
			platformHppCmd.autogeneratedNotice = product.cutehmi.skeleton.cpp.autogeneratedNotice
			platformHppCmd.macroPrefix = product.cutehmi.skeleton.cpp.macroPrefix
			platformHppCmd.sourceCode = function() {
				File.makePath(FileInfo.path(product.cutehmi.skeleton.cpp.platformHeader))
				var f = new TextFile(product.cutehmi.skeleton.cpp.platformHeader, TextFile.WriteOnly)
				try {
					f.writeLine("#ifndef " + includeGuard)
					f.writeLine("#define " + includeGuard)

					f.writeLine("")
					f.writeLine("// " + autogeneratedNotice)

					f.writeLine("")
					f.writeLine("#include <QtGlobal>")

					f.writeLine("")
					f.writeLine("#ifdef " + macroPrefix + "_DYNAMIC")
					f.writeLine("	#ifdef " + macroPrefix + "_BUILD")
					f.writeLine("		// Export symbols to dynamic library.")
					f.writeLine("		#define " + macroPrefix + "_API Q_DECL_EXPORT")
					f.writeLine("		#ifdef " + macroPrefix + "_TESTS")
					f.writeLine("			// Export symbols to dynamic library.")
					f.writeLine("			#define " + macroPrefix + "_PRIVATE Q_DECL_EXPORT")
					f.writeLine("		#else")
					f.writeLine("			#define " + macroPrefix + "_PRIVATE")
					f.writeLine("		#endif")
					f.writeLine("	#else")
					f.writeLine("		// Using symbols from dynamic library.")
					f.writeLine("		#define " + macroPrefix + "_API Q_DECL_IMPORT")
					f.writeLine("		#ifdef " + macroPrefix + "_TESTS")
					f.writeLine("			// Using symbols from dynamic library.")
					f.writeLine("			#define " + macroPrefix + "_PRIVATE Q_DECL_IMPORT")
					f.writeLine("		#else")
					f.writeLine("			#define " + macroPrefix + "_PRIVATE")
					f.writeLine("		#endif")
					f.writeLine("	#endif")
					f.writeLine("#else")
					f.writeLine("	#define " + macroPrefix + "_API")
					f.writeLine("	#define " + macroPrefix + "_PRIVATE")
					f.writeLine("#endif")

					f.writeLine("")
					f.writeLine("#endif")
				} finally {
					f.close()
				}
			}

			return [platformHppCmd]
		}

		Artifact {
			filePath: product.cutehmi.skeleton.cpp.platformHeader
			fileTags: ["hpp", "platform.hpp", "cutehmi.skeleton.cpp"]
		}
	}

	Rule {
		condition: product.cutehmi.skeleton.cpp.generateNonArtifact
		multiplex: true

		prepare: {
			// Qbs does not allow for a Rule without commands, so create empty command, if none of the real commands get into `result` array.
			var emptyCmd = new JavaScriptCommand()
			emptyCmd.silent = true;

			var result = [emptyCmd]

			if (product.cutehmi.skeleton.cpp.generateException && !File.exists(product.cutehmi.skeleton.cpp.exceptionHeader)) {
				var exceptionHppCmd = new JavaScriptCommand();
				exceptionHppCmd.description = "generating " + product.cutehmi.skeleton.cpp.exceptionHeader
				exceptionHppCmd.highlight = "codegen";
				exceptionHppCmd.includeGuard = product.cutehmi.skeleton.cpp.exceptionIncludeGuard
				exceptionHppCmd.autogeneratedNotice = product.cutehmi.skeleton.cpp.initiallyGeneratedNotice
				exceptionHppCmd.macroPrefix = product.cutehmi.skeleton.cpp.macroPrefix
				exceptionHppCmd.namespaceArray = product.cutehmi.skeleton.cpp.namespaceArray
				exceptionHppCmd.sourceCode = function() {
					File.makePath(FileInfo.path(product.cutehmi.skeleton.cpp.exceptionHeader))
					var f = new TextFile(product.cutehmi.skeleton.cpp.exceptionHeader, TextFile.WriteOnly)
					try {
						f.writeLine("#ifndef " + includeGuard)
						f.writeLine("#define " + includeGuard)

						f.writeLine("")
						f.writeLine("// " + autogeneratedNotice)

						f.writeLine("")
						f.writeLine("#include \"autogen/platform.hpp\"")
						f.writeLine("")
						f.writeLine("#include <cutehmi/ExceptionMixin.hpp>")

						f.writeLine("")
						for (var level in namespaceArray)
							f.writeLine("namespace " + namespaceArray[level] + " {")

						f.writeLine("")
						f.writeLine("class " + macroPrefix + "_API Exception:")
						f.writeLine("	public ::cutehmi::ExceptionMixin<Exception>")
						f.writeLine("{")
						f.writeLine("		typedef ExceptionMixin<Exception> Parent;")
						f.writeLine("")
						f.writeLine("	public:")
						f.writeLine("		using Parent::Parent;")
						f.writeLine("};")

						f.writeLine("")
						for (var level in namespaceArray)
							f.writeLine("}")

						f.writeLine("")
						f.writeLine("#endif")
					} finally {
						f.close()
					}
				}
				result.push(exceptionHppCmd)
			}

			if (product.cutehmi.skeleton.cpp.generateInit && !File.exists(product.cutehmi.skeleton.cpp.initHeader)) {
				var initHppCmd = new JavaScriptCommand();
				initHppCmd.description = "generating " + product.cutehmi.skeleton.cpp.initHeader
				initHppCmd.includeGuard = product.cutehmi.skeleton.cpp.initIncludeGuard
				initHppCmd.highlight = "codegen";
				initHppCmd.autogeneratedNotice = product.cutehmi.skeleton.cpp.initiallyGeneratedNotice
				initHppCmd.macroPrefix = product.cutehmi.skeleton.cpp.macroPrefix
				initHppCmd.namespaceArray = product.cutehmi.skeleton.cpp.namespaceArray
				initHppCmd.sourceCode = function() {
					File.makePath(FileInfo.path(product.cutehmi.skeleton.cpp.initHeader))
					var f = new TextFile(product.cutehmi.skeleton.cpp.initHeader, TextFile.WriteOnly)
					try {
						f.writeLine("#ifndef " + includeGuard)
						f.writeLine("#define " + includeGuard)

						f.writeLine("")
						f.writeLine("// " + autogeneratedNotice)

						f.writeLine("")
						f.writeLine("#include \"autogen/platform.hpp\"")
						f.writeLine("")
						f.writeLine("#include <cutehmi/Initializer.hpp>")

						f.writeLine("")
						for (var level in namespaceArray)
							f.writeLine("namespace " + namespaceArray[level] + " {")

						f.writeLine("")
						f.writeLine("/**")
						f.writeLine(" * %Init. This class performs initialization of the extension.")
						f.writeLine(" *")
						f.writeLine(" * Normally it is not advisable to create custom instances of this class as extension provides an instance on its own. This can be")
						f.writeLine(" * invalidated particulary by static builds in which case a global variable may not get into resulting binary.")
						f.writeLine(" */")

						f.writeLine("class " + macroPrefix + "_API Init final:")
						f.writeLine("	public ::cutehmi::Initializer<Init>")
						f.writeLine("{")
						f.writeLine("	public:")
						f.writeLine("		/**")
						f.writeLine("		 * Default constructor.")
						f.writeLine("		 */")
						f.writeLine("		Init();")
						f.writeLine("};")

						f.writeLine("")
						for (var level in namespaceArray)
							f.writeLine("}")

						f.writeLine("")
						f.writeLine("#endif")
					} finally {
						f.close()
					}
				}
				result.push(initHppCmd)
			}

			if (product.cutehmi.skeleton.cpp.generateInit && !File.exists(product.cutehmi.skeleton.cpp.initSource)) {
				var initCppCmd = new JavaScriptCommand();
				initCppCmd.description = "generating " + product.cutehmi.skeleton.cpp.initSource
				initCppCmd.highlight = "codegen";
				initCppCmd.autogeneratedNotice = product.cutehmi.skeleton.cpp.initiallyGeneratedNotice
				initCppCmd.namespaceArray = product.cutehmi.skeleton.cpp.namespaceArray
				initCppCmd.sourceCode = function() {
					File.makePath(FileInfo.path(product.cutehmi.skeleton.cpp.initSource))
					var f = new TextFile(product.cutehmi.skeleton.cpp.initSource, TextFile.WriteOnly)
					try {
						f.writeLine("#include \"Init.hpp\"")

						f.writeLine("")
						f.writeLine("// " + autogeneratedNotice)

						f.writeLine("")
						for (var level in namespaceArray)
							f.writeLine("namespace " + namespaceArray[level] + " {")

						f.writeLine("")
						f.writeLine("Init::Init():")
						f.writeLine("	::cutehmi::Initializer<Init>([]() {})")
						f.writeLine("{")
						f.writeLine("}")

						f.writeLine("")
						for (var level in namespaceArray)
							f.writeLine("}")
					} finally {
						f.close()
					}
				}
				result.push(initCppCmd)
			}

			if (product.cutehmi.skeleton.cpp.generateLoggingTest && !File.exists(product.cutehmi.skeleton.cpp.testLoggingSource)) {
				var loggingTestCmd = new JavaScriptCommand()
				loggingTestCmd.description = "generating " + product.cutehmi.skeleton.cpp.testLoggingSource
				loggingTestCmd.highlight = "codegen";
				loggingTestCmd.autogeneratedNotice = product.cutehmi.skeleton.cpp.initiallyGeneratedNotice
				loggingTestCmd.loggingCategoryId = product.name
				loggingTestCmd.namespaceArray = product.cutehmi.skeleton.cpp.namespaceArray
				loggingTestCmd.namespace = product.cutehmi.skeleton.cpp.namespace
				loggingTestCmd.includeDirPrefix = product.cutehmi.skeleton.cpp.dedicatedSubdir
				loggingTestCmd.sourceCode = function() {
					File.makePath(FileInfo.path(product.cutehmi.skeleton.cpp.testLoggingSource))
					var f = new TextFile(product.cutehmi.skeleton.cpp.testLoggingSource, TextFile.WriteOnly)
					try {
						f.writeLine("#include <" + includeDirPrefix + "/autogen/logging.hpp>")

						f.writeLine("")
						f.writeLine("#include <QtTest/QtTest>")

						f.writeLine("")
						f.writeLine("// " + autogeneratedNotice)

						f.writeLine("")
						for (var level in namespaceArray)
							f.writeLine("namespace " + namespaceArray[level] + " {")

						f.writeLine("")
						f.writeLine("class test_logging:")
						f.writeLine("	public QObject")
						f.writeLine("{")
						f.writeLine("	Q_OBJECT")
						f.writeLine("")
						f.writeLine("	private slots:")
						f.writeLine("		void loggingCategory();")
						f.writeLine("};")

						f.writeLine("")
						f.writeLine("void test_logging::loggingCategory()")
						f.writeLine("{")
						f.writeLine("	QCOMPARE(" + namespace + "::loggingCategory().categoryName(), \"" + loggingCategoryId + "\");")
						f.writeLine("}")

						f.writeLine("")
						for (var level in namespaceArray)
							f.writeLine("}")

						f.writeLine("")
						f.writeLine("QTEST_MAIN(" + namespace + "::test_logging)")
						f.writeLine("#include \"test_logging.moc\"")
					} finally {
						f.close()
					}
				}
				result.push(loggingTestCmd)
			}

			if (product.cutehmi.skeleton.cpp.generateTestsQbs && !File.exists(product.cutehmi.skeleton.cpp.testsQbs)) {
				var testsQbsCmd = new JavaScriptCommand();
				testsQbsCmd.description = "generating " + product.cutehmi.skeleton.cpp.testsQbs
				testsQbsCmd.highlight = "codegen";
				testsQbsCmd.autogeneratedNotice = product.cutehmi.skeleton.cpp.initiallyGeneratedNotice
				testsQbsCmd.sourceCode = function() {
					File.makePath(FileInfo.path(product.cutehmi.skeleton.cpp.testsQbs))
					var f = new TextFile(product.cutehmi.skeleton.cpp.testsQbs, TextFile.WriteOnly)
					try {
						f.writeLine("import qbs")

						f.writeLine("")
						f.writeLine("import \"Test.qbs\" as Test")

						f.writeLine("")
						f.writeLine("// " + autogeneratedNotice)

						f.writeLine("")
						f.writeLine("Project {")
						f.writeLine("	Test {")
						f.writeLine("		testName: \"test_logging\"")
						f.writeLine("")
						f.writeLine("		files: [")
						f.writeLine("			\"test_logging.cpp\"")
						f.writeLine("		]")
						f.writeLine("	}")
						f.writeLine("}")
					} finally {
						f.close()
					}
				}
				result.push(testsQbsCmd)
			}

			if (product.cutehmi.skeleton.cpp.generateTestsQbs && !File.exists(product.cutehmi.skeleton.cpp.testQbs)) {
				var testQbsCmd = new JavaScriptCommand();
				testQbsCmd.description = "generating " + product.cutehmi.skeleton.cpp.testQbs
				testQbsCmd.highlight = "codegen";
				testQbsCmd.autogeneratedNotice = product.cutehmi.skeleton.cpp.initiallyGeneratedNotice
				testQbsCmd.extensionName = product.name
				testQbsCmd.sourceCode = function() {
					File.makePath(FileInfo.path(product.cutehmi.skeleton.cpp.testQbs))
					var f = new TextFile(product.cutehmi.skeleton.cpp.testQbs, TextFile.WriteOnly)
					try {
						f.writeLine("import qbs")

						f.writeLine("")
						f.writeLine("import cutehmi")

						f.writeLine("")
						f.writeLine("// " + autogeneratedNotice)

						f.writeLine("")
						f.writeLine("cutehmi.Test {")
						f.writeLine("	testedProduct: parent.parent.name")
						f.writeLine("")
						f.writeLine("	Depends { name: product.testedProduct }")
						f.writeLine("}")
					} finally {
						f.close()
					}
				}
				result.push(testQbsCmd)
			}

			if (product.cutehmi.skeleton.cpp.generateQMLPlugin && !File.exists(product.cutehmi.skeleton.cpp.qmlPluginHeader)) {
				var qmlPluginHppCmd = new JavaScriptCommand();
				qmlPluginHppCmd.description = "generating " + product.cutehmi.skeleton.cpp.qmlPluginHeader
				qmlPluginHppCmd.highlight = "codegen";
				qmlPluginHppCmd.includeGuard = product.cutehmi.skeleton.cpp.qmlPluginIncludeGuard
				qmlPluginHppCmd.autogeneratedNotice = product.cutehmi.skeleton.cpp.initiallyGeneratedNotice
				qmlPluginHppCmd.macroPrefix = product.cutehmi.skeleton.cpp.macroPrefix
				qmlPluginHppCmd.namespaceArray = product.cutehmi.skeleton.cpp.namespaceArray
				qmlPluginHppCmd.namespaceArray.push("internal")
				qmlPluginHppCmd.sourceCode = function() {
					File.makePath(FileInfo.path(product.cutehmi.skeleton.cpp.qmlPluginHeader))
					var f = new TextFile(product.cutehmi.skeleton.cpp.qmlPluginHeader, TextFile.WriteOnly)
					try {
						f.writeLine("#ifndef " + includeGuard)
						f.writeLine("#define " + includeGuard)

						f.writeLine("")
						f.writeLine("// " + autogeneratedNotice)

						f.writeLine("")
						f.writeLine("#include <QQmlEngineExtensionPlugin>")

						f.writeLine("")
						for (var level in namespaceArray)
							f.writeLine("namespace " + namespaceArray[level] + " {")

						f.writeLine("")
						f.writeLine("/**")
						f.writeLine(" * QML plugin.")
						f.writeLine(" */")
						f.writeLine("class QMLPlugin:")
						f.writeLine("	public QQmlEngineExtensionPlugin")
						f.writeLine("{")
						f.writeLine("		Q_OBJECT")
						f.writeLine("		Q_PLUGIN_METADATA(IID QQmlEngineExtensionInterface_iid)")

						f.writeLine("")
						f.writeLine("	public:")
						f.writeLine("		void initializeEngine(QQmlEngine * engine, const char * uri) override;")

						f.writeLine("};")

						f.writeLine("")
						for (var level in namespaceArray)
							f.writeLine("}")

						f.writeLine("")
						f.writeLine("#endif")
					} finally {
						f.close()
					}
				}
				result.push(qmlPluginHppCmd)
			}

			if (product.cutehmi.skeleton.cpp.generateQMLPlugin && !File.exists(product.cutehmi.skeleton.cpp.qmlPluginSource)) {
				var qmlPluginCppCmd = new JavaScriptCommand();
				qmlPluginCppCmd.description = "generating " + product.cutehmi.skeleton.cpp.qmlPluginSource
				qmlPluginCppCmd.highlight = "codegen";
				qmlPluginCppCmd.autogeneratedNotice = product.cutehmi.skeleton.cpp.initiallyGeneratedNotice
				qmlPluginCppCmd.uri = product.baseName
				qmlPluginCppCmd.majorVersionMacro = product.cutehmi.skeleton.cpp.macroPrefix + "_MAJOR"
				qmlPluginCppCmd.namespaceArray = product.cutehmi.skeleton.cpp.namespaceArray
				qmlPluginCppCmd.namespaceArray.push("internal")
				qmlPluginCppCmd.sourceCode = function() {
					File.makePath(FileInfo.path(product.cutehmi.skeleton.cpp.qmlPluginSource))
					var f = new TextFile(product.cutehmi.skeleton.cpp.qmlPluginSource, TextFile.WriteOnly)
					try {
						f.writeLine("#include \"QMLPlugin.hpp\" // IWYU pragma: keep")

						f.writeLine("")
						f.writeLine("// " + autogeneratedNotice)

						f.writeLine("")
						for (var level in namespaceArray)
							f.writeLine("namespace " + namespaceArray[level] + " {")

						f.writeLine("")
						f.writeLine("void QMLPlugin::initializeEngine(QQmlEngine * engine, const char * uri)")
						f.writeLine("{")
						f.writeLine("	Q_UNUSED(uri)")
						f.writeLine("	Q_UNUSED(engine)")
						f.writeLine("}")

						f.writeLine("")
						for (var level in namespaceArray)
							f.writeLine("}")
					} finally {
						f.close()
					}
				}
				result.push(qmlPluginCppCmd)
			}

			return result
		}

		outputFileTags: ["cutehmi.skeleton.cpp"]
	}
}

//(c)C: Copyright © 2020-2024, Michał Policht <michal@policht.pl>. All rights reserved.
//(c)C: SPDX-License-Identifier: LGPL-3.0-or-later OR MIT
//(c)C: This file is a part of CuteHMI.
//(c)C: CuteHMI is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
//(c)C: CuteHMI is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
//(c)C: You should have received a copy of the GNU Lesser General Public License along with CuteHMI.  If not, see <https://www.gnu.org/licenses/>.
//(c)C: Additionally, this file is licensed under terms of MIT license as expressed below.
//(c)C: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//(c)C: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//(c)C: THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
